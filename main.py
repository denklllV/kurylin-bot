import os
import asyncio
import logging
from openai import OpenAI
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
)
# –ù–û–í–´–ô –ò–ú–ü–û–†–¢ –¥–ª—è Supabase
from supabase import create_client, Client

# 1. –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –ù–ê–°–¢–†–û–ô–ö–ê
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è ---
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
OPENROUTER_API_KEY = os.getenv('OPENROUTER_API_KEY')
PORT = int(os.environ.get('PORT', 8443))
WEBHOOK_URL = f"https://{os.getenv('RENDER_SERVICE_NAME')}.onrender.com/{TELEGRAM_TOKEN}"

# --- –ù–û–í–´–ô –ë–õ–û–ö: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ Supabase ---
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_KEY = os.getenv('SUPABASE_KEY')
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ AI-–∫–ª–∏–µ–Ω—Ç–∞ ---
client = OpenAI(base_url="https://openrouter.ai/api/v1", api_key=OPENROUTER_API_KEY)
MODEL_NAME = "mistralai/mistral-7b-instruct:free"

# --- –ó–∞–≥—Ä—É–∑–∫–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
KNOWLEDGE_BASE = ""
try:
    with open('bankruptcy_law.md', 'r', encoding='utf-8') as f: BANKRUPTCY_CONTEXT = f.read()
    with open('interviews.md', 'r', encoding='utf-8') as f: INTERVIEWS_CONTEXT = f.read()
    KNOWLEDGE_BASE = BANKRUPTCY_CONTEXT + "\n\n" + INTERVIEWS_CONTEXT
except FileNotFoundError:
    logger.warning("–í–Ω–∏–º–∞–Ω–∏–µ: –§–∞–π–ª—ã —Å –±–∞–∑–æ–π –∑–Ω–∞–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")

# --- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler ---
GET_NAME, GET_DEBT, GET_INCOME, GET_REGION = range(4)

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
main_keyboard = ReplyKeyboardMarkup([['üìù –ó–∞–ø–æ–ª–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É', 'üßë‚Äçüíº –°–≤—è–∑–∞—Ç—å—Å—è —Å —á–µ–ª–æ–≤–µ–∫–æ–º']], resize_keyboard=True)
cancel_keyboard = ReplyKeyboardMarkup([['–û—Ç–º–µ–Ω–∞']], resize_keyboard=True)

# 2. –§–£–ù–ö–¶–ò–ò-–û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ë–û–¢–ê

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î."""
    user = update.effective_user
    # –ü—ã—Ç–∞–µ–º—Å—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º —Å—Ç–∞—Ä—Ç–µ
    try:
        supabase.table('users').upsert({
            'user_id': user.id,
            'username': user.username,
            'first_name': user.first_name
        }).execute()
        logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.id} —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω –≤ –ë–î.")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id} –≤ Supabase: {e}")

    await update.message.reply_text(
        '–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ! –Ø –≤–∞—à —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–π AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç.\n\n'
        'üìù –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∞–Ω–∫–µ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.\n'
        '‚ùì –ß—Ç–æ–±—ã –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å, –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –µ–≥–æ –≤ —ç—Ç–æ—Ç —á–∞—Ç.',
        reply_markup=main_keyboard
    )

# --- –ù–û–í–´–ï –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---

def save_lead_to_database(user_id: int, lead_data: dict):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –∞–Ω–∫–µ—Ç—ã –≤ —Ç–∞–±–ª–∏—Ü—É 'leads' –≤ Supabase."""
    try:
        data_to_insert = {
            'user_id': user_id,
            'name': lead_data.get('name'),
            'debt_amount': lead_data.get('debt'),
            'income_source': lead_data.get('income'),
            'region': lead_data.get('region')
        }
        supabase.table('leads').insert(data_to_insert).execute()
        logger.info(f"–ê–Ω–∫–µ—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –ë–î.")
        return True
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∞–Ω–∫–µ—Ç—ã –¥–ª—è {user_id} –≤ Supabase: {e}")
        return False

def send_notification_to_manager(summary: str):
    """–§—É–Ω–∫—Ü–∏—è-–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –º–µ–Ω–µ–¥–∂–µ—Ä—É."""
    # –í –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –±—É–¥–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–π –∫–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram-—á–∞—Ç
    logger.info("--- –£–í–ï–î–û–ú–õ–ï–ù–ò–ï –ú–ï–ù–ï–î–ñ–ï–†–£ (–ó–ê–ì–õ–£–®–ö–ê) ---")
    logger.info(summary)
    logger.info("-----------------------------------------")


# --- –õ–û–ì–ò–ö–ê –ê–ù–ö–ï–¢–ò–†–û–í–ê–ù–ò–Ø (–ò–ó–ú–ï–ù–ï–ù–ê) ---

async def start_form(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ù–∞—á–∏–Ω–∞–µ—Ç —Å—Ü–µ–Ω–∞—Ä–∏–π –∞–Ω–∫–µ—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."""
    await update.message.reply_text(
        "–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–∏—Å—Ç—É–ø–∞–µ–º –∫ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—é –∞–Ω–∫–µ—Ç—ã.\n\n–ö–∞–∫ —è –º–æ–≥—É –∫ –≤–∞–º –æ–±—Ä–∞—â–∞—Ç—å—Å—è?",
        reply_markup=cancel_keyboard
    )
    return GET_NAME

async def get_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['name'] = update.message.text
    await update.message.reply_text("–ö–∞–∫–∞—è —É –≤–∞—Å –æ–±—â–∞—è —Å—É–º–º–∞ –∑–∞–¥–æ–ª–∂–µ–Ω–Ω–æ—Å—Ç–∏?", reply_markup=cancel_keyboard)
    return GET_DEBT

async def get_debt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['debt'] = update.message.text
    await update.message.reply_text("–£–∫–∞–∂–∏—Ç–µ –≤–∞—à –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–æ—Ö–æ–¥–∞.", reply_markup=cancel_keyboard)
    return GET_INCOME

async def get_income(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['income'] = update.message.text
    await update.message.reply_text("–í –∫–∞–∫–æ–º —Ä–µ–≥–∏–æ–Ω–µ (–æ–±–ª–∞—Å—Ç—å, –∫—Ä–∞–π) –≤—ã –ø—Ä–æ–ø–∏—Å–∞–Ω—ã?", reply_markup=cancel_keyboard)
    return GET_REGION

async def get_region(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ó–∞–≤–µ—Ä—à–∞–µ—Ç –∞–Ω–∫–µ—Ç—É, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ."""
    context.user_data['region'] = update.message.text
    user_info = context.user_data
    user_id = update.effective_user.id
    
    summary = (
        f"<b>–ù–æ–≤–∞—è –∞–Ω–∫–µ—Ç–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è @{update.effective_user.username} (ID: {user_id})</b>\n\n"
        f"- <b>–ò–º—è:</b> {user_info.get('name', '–Ω–µ —É–∫–∞–∑–∞–Ω–æ')}\n"
        f"- <b>–°—É–º–º–∞ –¥–æ–ª–≥–∞:</b> {user_info.get('debt', '–Ω–µ —É–∫–∞–∑–∞–Ω–æ')}\n"
        f"- <b>–ò—Å—Ç–æ—á–Ω–∏–∫ –¥–æ—Ö–æ–¥–∞:</b> {user_info.get('income', '–Ω–µ —É–∫–∞–∑–∞–Ω–æ')}\n"
        f"- <b>–†–µ–≥–∏–æ–Ω:</b> {user_info.get('region', '–Ω–µ —É–∫–∞–∑–∞–Ω–æ')}"
    )
    
    # –®–ê–ì 1: –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    save_lead_to_database(user_id=user_id, lead_data=user_info)

    # –®–ê–ì 2: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (–ø–æ–∫–∞ –≤ –ª–æ–≥–∏)
    send_notification_to_manager(summary)

    # –®–ê–ì 3: –û—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    await update.message.reply_text(
        "–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à–∏ –æ—Ç–≤–µ—Ç—ã! –ù–∞—à–∏ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã —Å–∫–æ—Ä–æ —Å–≤—è–∂—É—Ç—Å—è —Å –≤–∞–º–∏.",
        reply_markup=main_keyboard
    )
    context.user_data.clear()
    return ConversationHandler.END

# ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏: cancel, contact_human, handle_message, main –∏ —Ç.–¥. –±–µ–∑ –∫–ª—é—á–µ–≤—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π)
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∞–Ω–∫–µ—Ç—ã –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=main_keyboard)
    context.user_data.clear()
    return ConversationHandler.END

async def contact_human(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text("–í—ã –≤—ã–±—Ä–∞–ª–∏ '–°–≤—è–∑–∞—Ç—å—Å—è —Å —á–µ–ª–æ–≤–µ–∫–æ–º'. –≠—Ç–æ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.", reply_markup=main_keyboard)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_question = update.message.text
    await update.message.reply_text("–ò—â—É –æ—Ç–≤–µ—Ç –≤ –±–∞–∑–µ –∑–Ω–∞–Ω–∏–π...")
    loop = asyncio.get_running_loop()
    ai_answer = await loop.run_in_executor(None, get_ai_response, user_question)
    cleaned_answer = ai_answer.replace('<p>', '').replace('</p>', '')
    while '\n\n\n' in cleaned_answer: cleaned_answer = cleaned_answer.replace('\n\n\n', '\n\n')
    try:
        await update.message.reply_text(cleaned_answer, parse_mode='HTML', reply_markup=main_keyboard)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è HTML: {e}. –û—Ç–ø—Ä–∞–≤–∫–∞ –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.")
        await update.message.reply_text(cleaned_answer, reply_markup=main_keyboard)

def main() -> None:
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    form_button_filter = filters.Regex('^üìù –ó–∞–ø–æ–ª–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É$')
    contact_button_filter = filters.Regex('^üßë‚Äçüíº –°–≤—è–∑–∞—Ç—å—Å—è —Å —á–µ–ª–æ–≤–µ–∫–æ–º$')
    conv_handler = ConversationHandler(
        entry_points=[MessageHandler(form_button_filter, start_form)],
        states={
            GET_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex('^–û—Ç–º–µ–Ω–∞$'), get_name)],
            GET_DEBT: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex('^–û—Ç–º–µ–Ω–∞$'), get_debt)],
            GET_INCOME: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex('^–û—Ç–º–µ–Ω–∞$'), get_income)],
            GET_REGION: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex('^–û—Ç–º–µ–Ω–∞$'), get_region)],
        },
        fallbacks=[CommandHandler('cancel', cancel), MessageHandler(filters.Regex('^–û—Ç–º–µ–Ω–∞$'), cancel)],
    )
    application.add_handler(CommandHandler("start", start))
    application.add_handler(conv_handler)
    application.add_handler(MessageHandler(contact_button_filter, contact_human))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & ~form_button_filter & ~contact_button_filter, handle_message))
    logger.info(f"–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –Ω–∞ –ø–æ—Ä—Ç—É {PORT}.")
    application.run_webhook(listen="0.0.0.0", port=PORT, url_path=TELEGRAM_TOKEN, webhook_url=WEBHOOK_URL)

def find_relevant_chunks(question: str, knowledge_base: str, max_chunks=5) -> str:
    chunks = knowledge_base.split('\n\n')
    question_keywords = set(question.lower().split())
    scored_chunks = []
    for chunk in chunks:
        chunk_words = set(chunk.lower().split())
        score = len(question_keywords.intersection(chunk_words))
        if score > 0: scored_chunks.append((score, chunk))
    scored_chunks.sort(reverse=True, key=lambda x: x[0])
    top_chunks = [chunk for score, chunk in scored_chunks[:max_chunks]]
    return "\n\n".join(top_chunks)

def get_ai_response(question: str) -> str:
    dynamic_context = find_relevant_chunks(question, KNOWLEDGE_BASE)
    system_prompt = ("–¢–≤–æ—è —Ä–æ–ª—å ‚Äî –ø–µ—Ä–≤–æ–∫–ª–∞—Å—Å–Ω—ã–π —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–π –ø–æ–º–æ—â–Ω–∏–∫...") # –°–æ–∫—Ä–∞—â–µ–Ω–æ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏
    user_prompt = f"–ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π:\n{dynamic_context}\n\n–í–æ–ø—Ä–æ—Å –∫–ª–∏–µ–Ω—Ç–∞: {question}"
    try:
        completion = client.chat.completions.create(model=MODEL_NAME, messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}])
        return completion.choices[0].message.content
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ OpenRouter AI: {e}")
        return "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—à–µ–Ω–∏–∏ –∫ AI-—Å–µ—Ä–≤–∏—Å—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."

if __name__ == "__main__":
    main()